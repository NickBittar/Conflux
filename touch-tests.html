<!DOCTYPE html>
<html>
<head>

<style>
* {
	margin: 0;
	padding: 0;
	-webkit-touch-callout: none; /* iOS Safari */
	-webkit-user-select: none;   /* Chrome/Safari/Opera */
	-khtml-user-select: none;    /* Konqueror */
	-moz-user-select: none;      /* Firefox */
	-ms-user-select: none;       /* Internet Explorer/Edge */
	user-select: none;
}
.container {
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;

}
.block {
	display: flex;

	width: 90%;
	height: 200px;
	background-color: #ccd;
	position: relative;
}
.time-block {
	display: flex;
	height: 200px;
	width: 40px;
	background: -webkit-linear-gradient(left, #05DC33 33%, #55DE72 33%, #55DD71 66%, rgb(5, 220, 51) 30%);
	position: absolute;
	bottom: 0px;
}
#time {
	height: 200px;
	width: 100px;
}
.handle {
    height: 100%;
    width: 20px;
    background-color: #00f;
    position: absolute;
}
.left {
    left: 0px;
}
.right {
    right: 0px;
}

#debug {
	width: 100%;
	background-color: #333;
	color: #eee;
}
</style>
<title></title>
</head>
<body>
	<div class="container">
		<div class="block" id="block">

		</div>
	</div>
	<div id="debug">
		Debug<br>
		Cursor: (<span id="cursor"></span>)<br>
		Target: <span id="target"></span><br>
	</div>
	<script>
	var doc = document,
	day = doc.getElementById("block");
	var debug = {
		div: document.getElementById("debug"),
		write: function(line) {
			this.div.innerHTML += "<br>" + line;
		},
		u: function(ele, val) {
			document.getElementById(ele).textContent = val;
		}
	};

	function DateRange(element) {
		this.days = [];
		this.element = element;
	}

	function Day(element) {
		this.times = [];
		this.element = element;

		// Methods
		this.add = function(block) {
			this.times.push(block);
		};

		this.delete = function(block) {
			block.element.remove();	// Delete HTML element from DOM
			return this.times.splice(this.times.indexOf(block), 1);
		};

		this.find = function(element) {
			for (let i of this.times) {
				if(i.element === element) {
					return i;
				}
			}
			return null;
		};

		this.cleanupOverlaps = function ()
		{
		let times = this.times;
			for(let i = 0; i < times.length; i++)
			{
				for(let j = 0; j < times.length; j++)
				{
					if (i !== j) {
						if (this.overlap(times[i], times[j])) {
							i = 0;
							j = 0;
						}
					}
				}
			}
		}
		this.overlap = function(div1, div2)
		{
			let success = false;
			let rect1 = div1.element.getBoundingClientRect();
			let rect2 = div2.element.getBoundingClientRect();
			if(!(rect1.right < rect2.left || rect1.left > rect2.right ))	// If there is an overlap
			{
				if(rect2.right < rect1.right && rect2.left > rect1.left)	// div1 contains div2
				{
		      this.delete(div2);
					success = true;
				}
				else if(rect1.right < rect2.right && rect1.left > rect2.left)	// div2 contains div1
				{
					this.delete(div1);
					success = true;
				}
				else if(rect1.left < rect2.left)	// div2 overlaps div1 on div1's right side
				{
					div1.width = rect2.width + rect2.left - rect1.left;
					div1.updateDOM();
					this.delete(div2);
					success = true;
				}
				else if(rect1.left > rect2.left) // div1 overlaps div2 on div2's right side
				{
					div2.width = rect1.width + rect1.left - rect2.left;
					div2.updateDOM();
					this.delete(div1);
					success = true;
				}
		    else if(rect1.left === rect2.left)
		    {
		      if(rect1.width >= rect2.width) {
						this.delete(div2);
		      }
		      else {
						this.delete(div1);
		      }
		      success = true;
		    }
			}
			return success;
		}


	}

	function Block(day, startX, minWidth) {
		// Properties
		this.day = day;
		this.startX = startX - day.offsetLeft - 20;
		this.lastX = this.startX ;
		this.dx = 0;
		this.left = this.startX;
		this.width = 40;
		this.minWidth = minWidth || 0;
		this.element = document.createElement('div');
		this.element.className = 'time-block';
		this.element.style.left = this.left + 'px';
		this.day.appendChild(this.element);
		this.pan = false;	// Used for modifying the time block.
		this.cursorOffset = 0;

		this.leftHandle = document.createElement('div');
		this.leftHandle.className = 'handle left';
		this.rightHandle = document.createElement('div');
		this.rightHandle.className = 'handle right';
		this.element.appendChild(this.leftHandle);
		this.element.appendChild(this.rightHandle);

		// Constants
		this.fineMovementY = this.day.offsetTop + this.day.offsetHeight + 200;

		// Methods
		this.update = function(event) {
			let newX = event.clientX;
			if(newX < this.day.offsetLeft) {
				newX = this.day.offsetLeft;
			}

			// Handles scrub speed reduction when cursor is below time block
			if (event.clientY > this.fineMovementY) {
				console.debug('sloooow');
				let reduction = (1 - (event.clientY-this.fineMovementY)/300);	// 300 is arbitrary
				if (reduction > 1) { reduction = 1; }
				if (reduction < 0) { reduction = 0; }

				//dx += event.movementX*reduction;	// Can delete, was trying to replace 'movementX'
				this.dx += (newX - this.lastX) * reduction;

			} else {
				this.dx = newX-this.day.offsetLeft - this.startX;
			}
			this.lastX = newX;
			if (this.pan) {
				this.panBlock(event);
			} else if (this.expandLeft) {
				this.expandLeftBlock();
			} else if (this.expandRight) {
				this.expandRightBlock();
			} else {
				// Determines how the time block changes
				if (this.dx > 0) {
					this.left = this.startX;
				} else if (this.dx < 0) {
					this.left = this.dx + this.startX;
				}
				this.width = Math.abs(this.dx);


				if (this.left < 0) {
					this.left = 0;
					// This handles the issue where dragging the handle off the edge would make the width grow
					//this.width += newX - this.day.offsetLeft - this.cursorOffset;
				}
				if (this.left > this.day.offsetWidth-this.minWidth) {
					this.left = this.day.offsetWidth-this.minWidth;
				}
				if (this.width + this.left > this.day.offsetWidth) {
					this.width = this.day.offsetWidth-this.left;
				}
			}
			this.updateDOM();
		};

		this.panBlock = function(event) {
			this.left = this.startX + this.dx - this.cursorOffset;
			if(this.left < 0) {this.left = 0;}
			if(this.left+this.width > this.day.offsetWidth) { this.left = this.day.offsetWidth - this.width;}
			console.info(event.clientY);
		};

		this.expandLeftBlock = function() {
			let newLeft, newWidth; // new left and width
			newLeft = this.dx + this.startX - this.cursorOffset;
			newWidth = Math.abs(this.dx) + this.cursorOffset;

			// So it can not go before the start of the day
			if(newLeft < 0) {
				newLeft = 0;
				newWidth += this.lastX - this.day.offsetLeft - this.cursorOffset;
			}
			// Only update if the left handle stays on left side
			if(this.startX - newLeft >= 2*this.leftHandle.offsetWidth) {
				this.left = newLeft;
				this.width = newWidth;
			} else {
				this.left = this.startX - 2*this.leftHandle.offsetWidth;
				this.width = 2*this.leftHandle.offsetWidth;
			}
		};

		this.expandRightBlock = function() {
			let newWidth;
			newWidth = this.dx - this.cursorOffset;

			// So it can not go past the day
			if(newWidth > this.day.offsetWidth-this.left) {
				newWidth = this.day.offsetWidth-this.left;
			}
			// Handles when the right handle tries to overlap the left one
			if(newWidth >= 2*this.rightHandle.offsetWidth) {
				this.width = newWidth;
			} else {
				this.width = 2*this.rightHandle.offsetWidth;
			}
		};

		this.updateDOM = function() {
			this.element.style.left = (this.left/this.day.offsetWidth)*100 + '%';
			this.element.style.width = (this.width/this.day.offsetWidth)*100 + '%';
		};
	}

	var dayObj = new Day(day);
	var currTimeBlock = null;

	window.addEventListener('mousedown', mDown, false);
	window.addEventListener('mouseup', mUp, false);
	window.addEventListener('mousemove', mMove, false);
	day.addEventListener('touchstart', touchStart, false);
	day.addEventListener('touchmove', touchMove, false);
	day.addEventListener('touchend', touchEnd, false);

	function mDown(event) {
		if(event.target.id === 'block') {
			currTimeBlock = new Block(day, event.clientX);
			dayObj.add(currTimeBlock);
		} else if (event.target.className === 'time-block') {
			currTimeBlock = dayObj.find(event.target);
			currTimeBlock.pan = true;
			currTimeBlock.cursorOffset = event.clientX - currTimeBlock.left - currTimeBlock.day.offsetLeft;
		} else if (event.target.className.includes('handle')) {
			currTimeBlock = dayObj.find(event.target.parentElement);
			if (event.target.className.includes('left')) {
				currTimeBlock.cursorOffset = event.clientX - currTimeBlock.left - currTimeBlock.day.offsetLeft;
				currTimeBlock.startX = currTimeBlock.left+currTimeBlock.width;
				currTimeBlock.expandLeft = true;
				currTimeBlock.expandRight = false;
			} else {
				currTimeBlock.cursorOffset = event.clientX - (currTimeBlock.left+currTimeBlock.width) - currTimeBlock.day.offsetLeft;
				currTimeBlock.startX = currTimeBlock.left;
				currTimeBlock.expandLeft = false;
				currTimeBlock.expandRight = true;
			}
		}
		if(currTimeBlock != null) {
			currTimeBlock.element.style.zIndex = 1;
		}
	}

	function mUp(event) {
		if (currTimeBlock !== null) {
			currTimeBlock.pan = false;
			currTimeBlock.cursorOffset = 0;
			currTimeBlock.element.style.zIndex = 0;
			currTimeBlock = null;

			dayObj.cleanupOverlaps();
			/*
			if (dx > 0) {

			} else if (dx < 0) {

			} else {
				console.warn('nothing happened.');
			}
			*/
		}
	}

	function mMove(event) {
		if (currTimeBlock !== null) {
			if (event.buttons === 1) {
				currTimeBlock.update(event);
			}
		}
	}

	function touchStart(event) {

		if(event.touches.length === 1) {
			event.preventDefault();
			if(event.target.id === 'block') {
				if(currTimeBlock !==  null) {
					console.error('Touch started but currTimeBlock was not null (not pushed)');
					touchEnd();
				}
				currTimeBlock = new Block(day, event.touches[0].clientX);
				dayObj.add(currTimeBlock);
			} else if (event.target.className === 'time-block') {
				currTimeBlock = dayObj.find(event.target);
				currTimeBlock.pan = true;
				currTimeBlock.cursorOffset = event.touches[0].clientX - currTimeBlock.left - currTimeBlock.day.offsetLeft;
			} else if (event.target.className.includes('handle')) {
				currTimeBlock = dayObj.find(event.target.parentElement);
				if (event.target.className.includes('left')) {
					currTimeBlock.cursorOffset = event.touches[0].clientX - currTimeBlock.left - currTimeBlock.day.offsetLeft;
					currTimeBlock.startX = currTimeBlock.left+currTimeBlock.width;
					currTimeBlock.expandLeft = true;
					currTimeBlock.expandRight = false;
				} else {
					currTimeBlock.cursorOffset = event.touches[0].clientX - (currTimeBlock.left+currTimeBlock.width) - currTimeBlock.day.offsetLeft;
					currTimeBlock.startX = currTimeBlock.left;
					currTimeBlock.expandLeft = false;
					currTimeBlock.expandRight = true;
				}
			}
			if(currTimeBlock !== null) {
				currTimeBlock.element.style.zIndex = 1;
			}
		}
	}

	function touchMove(event) {
		event.preventDefault();
		if(currTimeBlock !== null) {
			if(event.touches.length === 1) {
				currTimeBlock.update(event.touches[0]);
			}
		}
	}

	function touchEnd(event) {
		event.preventDefault();
		if(currTimeBlock !== null) {
			currTimeBlock.pan = false;
			currTimeBlock.cursorOffset = 0;
			currTimeBlock.element.style.zIndex = 0;
			currTimeBlock = null;
			dayObj.cleanupOverlaps();
		}
	}



	function Time(event) {
		console.log(event);
		debug.u('cursor', event.offsetX + ', ' + event.offsetY);
		debug.u('target', event.target.className);
	}

	function create(event) {
		debug.u('cursor', event.offsetX + ', ' + event.offsetY);
		debug.u('target', event.target.className);
		var div = document.createElement("div");
		div.className = "time-block";
		div.addEventListener("click", Time, false);
		event.target.appendChild(div);
	}

	</script>
</body>
</html>
